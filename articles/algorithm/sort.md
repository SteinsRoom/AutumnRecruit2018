
# 基于比较的排序算法
## 选择排序
* 简介
这是一种最简单直观的排序,是稳定的排序算法。
* 原理
每一趟从待排序的数列中选出最小的（最大的）一个元素，顺序放到已经排好序的数列的最后，直到所有待排元素全部排好.
* 时间复杂度
O(n^2)
* 过程演示
```shell
|1 3 5 7 9 2 4 6 8 0  选择第一小的数与0位交换
i j
1 3 5 7 9 2 4 6 8 0
i                 j
                 min
0| 3 5 7 9 2 4 6 8 1  选择第二小的数与1位交换
  i j
0 3 5 7 9 2 4 6 8 1
  i               j
                 min
0 1| 5 7 9 2 4 6 8 3  选择第三小的数与2位交换
0 1 2| 7 9 5 4 6 8 3  选择第四小的数与3位交换
0 1 2 3| 9 5 4 6 8 7  选择第五小的数与4位交换
0 1 2 3 4| 5 9 6 8 7  选择第六小的数与5位交换
0 1 2 3 4 5| 9 6 8 7  选择第七小的数与6位交换
0 1 2 3 4 5 6| 9 8 7  选择第八小的数与7位交换
0 1 2 3 4 5 6 7| 8 9  选择第九小的数与8位交换
0 1 2 3 4 5 6 7 8| 9  待排只剩一个数，排序结束

作者：chad_it
链接：https://www.jianshu.com/p/4dac9c141bd5
來源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
```
* 代码
```java
    public void selectSort(int[] arrays) {
        for (int i = 0;i < arrays.length; ++i) {
            int min = arrays[i];
            int pos = i;
            for (int j = i + 1;j < arrays.length; ++j) {
                if (arrays[j] > min) {
                    min = arrays[j];
                    pos = j;
                }
            }
            swap(arrays, i, pos);
        }
    }

    private void swap(int [] arrays, int pos1, int pos2) {
        int temp = arrays[pos2];
        arrays[pos2] = arrays[pos1];
        arrays[pos1] = temp;
    }
```
## 插入排序
* 简介
这也是一种简单直观的排序算法，是稳定的排序算法。
* 原理
构建有序序列，即对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
* 时间复杂度
O(n^2)。
* 过程演示
```shell
1 3 5 7 9 2 4 6 8 0
1 3 5 7 9 9 4 6 8 0  temp=2
1 3 5 7 7 9 4 6 8 0
1 3 5 5 7 9 4 6 8 0
1 3 3 5 7 9 4 6 8 0
1 2 3 5 7 9 4 6 8 0
1 2 3 5 7 9 9 6 8 0  temp=4
1 2 3 5 7 7 9 6 8 0
1 2 3 5 5 7 9 6 8 0
1 2 3 4 5 7 9 6 8 0
1 2 3 4 5 7 9 9 8 0  temp=6
1 2 3 4 5 7 7 9 8 0
1 2 3 4 5 6 7 9 8 0
1 2 3 4 5 6 7 9 9 0  temp=8
1 2 3 4 5 6 7 8 9 0
1 2 3 4 5 6 7 8 9 9  temp=0
1 2 3 4 5 6 7 8 8 9
1 2 3 4 5 6 7 7 8 9
1 2 3 4 5 6 6 7 8 9
1 2 3 4 5 5 6 7 8 9
1 2 3 4 4 5 6 7 8 9
1 2 3 3 4 5 6 7 8 9
1 2 2 3 4 5 6 7 8 9
1 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8 9
```
* 代码
```java
//插入排序
    public void insert(int[] array) {
        int temp;
        for (int i = 0;i < array.length - 1; ++i) {
            temp = array[i + 1];
            int j = i + 1;
            while (j> 0 && temp < array[j - 1]) {
                array[j] = array[j - 1];
                --j;
            }
            array[j] = temp;
        }
    }
```
## 希尔排序

* 简介
也称递减增量排序算法，是插入排序的一种高速且稳定的改进版本。我把希尔排序叫做分组插入排序。是不稳定的排序算法。
* 原理
先把要排序的序列元素以序列长度的1/2为间隔（向下取证）两两分为一组，对每组分别进行插入排序，排完后再以序列长度的1/4为间隔（向下取整）分组，对每组分别进行插入排序，重复上述操作，直到间隔为一，即最后一趟为普通的插入排序（此时序列已基本有序）。
* 时间复杂度
取决于分组间隔gap的值，在O(n(lgn)2)~O(n2)之间
* 过程演示
```shell
1 3 5 7 9 2 4 6 8 0  gap=5
1 3 5 7 9 2 4 6 8 9  temp=0
1 3 5 7 0 2 4 6 8 9  gap=2
1 3 5 7 5 2 4 6 8 9  temp=0
1 3 1 7 5 2 4 6 8 9
0 3 1 7 5 2 4 6 8 9
0 3 1 7 5 2 5 6 8 9  temp=4
0 3 1 7 4 2 5 6 8 9
0 3 1 7 4 7 5 6 8 9  temp=2
0 3 1 3 4 7 5 6 8 9
0 2 1 3 4 7 5 6 8 9
0 2 1 3 4 7 5 7 8 9  temp=6
0 2 1 3 4 6 5 7 8 9  gap=1
0 2 2 3 4 6 5 7 8 9  temp=1
0 1 2 3 4 6 5 7 8 9
0 1 2 3 4 6 6 7 8 9  temp=5
0 1 2 3 4 5 6 7 8 9

```
<div align="center"><img src="../../resources/images/algorithm/shell_sort.png"></div>


* 代码
```java
    public void shellSort(int[] array) {
        int gap = array.length / 2;
        while (gap >= 1) {
            for (int i = 0; i < array.length - gap; ++i) {
                insertSort(array, i, gap);
            }
            gap = gap / 2;
        }
    }

    //插入排序
    public void insertSort(int[] array, int start, int gap) {
        int temp;
        for (int i = start;i < start + gap - 1; ++i) {
            temp = array[i + 1];
            int j = i + 1;
            while (j> start && temp < array[j - 1]) {
                array[j] = array[j - 1];
                --j;
            }
            array[j] = temp;
        }
    }
```
## 冒泡排序
* 简介
是一种简单的排序算法。因其排序过程中较大（较小）元素会慢慢“浮到”顶部，就像鱼吐泡泡而得名。是稳定的排序。
* 原理
重复的遍历要排序的序列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，直到序列有序。
* 时间复杂度
O(n^2)。
* 过程演示
```shell
|1 3 5 7 9 2 4 6 8 0
|1 3 5 7 9 2 4 6 0 8
|1 3 5 7 9 2 4 0 6 8
|1 3 5 7 9 2 0 4 6 8
|1 3 5 7 9 0 2 4 6 8
|1 3 5 7 0 9 2 4 6 8
|1 3 5 0 7 9 2 4 6 8
|1 3 0 5 7 9 2 4 6 8
|1 0 3 5 7 9 2 4 6 8
0 1| 3 5 7 9 2 4 6 8
0 1| 3 5 7 2 9 4 6 8
0 1| 3 5 2 7 9 4 6 8
0 1| 3 2 5 7 9 4 6 8
0 1 2 3| 5 7 9 4 6 8
0 1 2 3| 5 7 4 9 6 8
0 1 2 3| 5 4 7 9 6 8
0 1 2 3 4 5| 7 9 6 8
0 1 2 3 4 5| 7 6 9 8
0 1 2 3 4 5 6 7| 9 8
0 1 2 3 4 5 6 7 8 9|
```
* 代码

## 快速排序
* 简介

* 原理

* 时间复杂度

* 过程演示

* 代码

## 归并排序
* 简介

* 原理

* 时间复杂度

* 过程演示

* 代码

# 基于计算的排序算法(时间复杂度O(n))


# 参考
* [Java排序算法](https://www.jianshu.com/p/4dac9c141bd5)